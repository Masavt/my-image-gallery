<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forbidden Stories v3 - Ultimate Femdom Experience Engine</title>
    <meta name="description" content="Every session, a new door opens. AI-powered immersive femdom stories.">
    
    <!-- Critical CSS -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,700;1,400&display=swap');
        
        :root {
            --blood: #8B0000;
            --crimson: #DC143C;
            --void: #0a0a0a;
            --ash: #1a1a1a;
            --bone: #fafafa;
            --venom: #ff1744;
            --latex: #1a1a1a;
            --chain: #c0c0c0;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
        }
        
        body {
            background: var(--void);
            color: var(--bone);
            font-family: 'Crimson Text', serif;
            overflow: hidden;
            position: relative;
            height: 100vh;
            cursor: none;
        }
        
        /* Custom Cursor */
        .cursor {
            width: 20px;
            height: 20px;
            border: 2px solid var(--venom);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            transition: all 0.1s ease;
            z-index: 10000;
            mix-blend-mode: difference;
        }
        
        .cursor.active {
            transform: scale(2);
            background: var(--venom);
            opacity: 0.5;
        }
        
        /* Main Container */
        .experience-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            overflow: hidden;
        }
        
        /* Scene Viewer */
        .scene-viewer {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: var(--void);
        }
        
        .scene-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Background Layer */
        .bg-layer {
            z-index: 1;
            filter: blur(2px) brightness(0.3);
            transform: scale(1.1);
        }
        
        /* Main Subject Layer */
        .subject-layer {
            z-index: 2;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .subject-image {
            max-width: 80%;
            max-height: 80%;
            object-fit: contain;
            filter: contrast(1.2) saturate(0.9);
            animation: breathe 4s ease-in-out infinite;
        }
        
        @keyframes breathe {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        /* Effects Layer */
        .effects-layer {
            z-index: 3;
            pointer-events: none;
            background: 
                radial-gradient(circle at center, transparent 40%, rgba(0,0,0,0.8) 100%),
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(139,0,0,0.03) 2px,
                    rgba(139,0,0,0.03) 4px
                );
            mix-blend-mode: multiply;
        }
        
        /* Text Layer */
        .text-layer {
            z-index: 4;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.95) 0%, transparent 100%);
            padding: 60px 40px 40px;
            transform: translateY(100%);
            transition: transform 0.5s ease;
        }
        
        .text-layer.active {
            transform: translateY(0);
        }
        
        .scene-text {
            max-width: 800px;
            margin: 0 auto;
            font-size: 1.3em;
            line-height: 1.8;
            letter-spacing: 0.02em;
        }
        
        .command-text {
            color: var(--venom);
            font-weight: 700;
            font-style: italic;
            text-shadow: 0 0 20px rgba(255,23,68,0.5);
        }
        
        .whisper-text {
            opacity: 0.7;
            font-style: italic;
        }
        
        /* Control Panel */
        .control-panel {
            width: 300px;
            background: var(--ash);
            border-left: 1px solid var(--blood);
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 100;
        }
        
        /* Intensity Dial */
        .intensity-dial {
            padding: 30px;
            border-bottom: 1px solid rgba(139,0,0,0.3);
        }
        
        .dial-container {
            position: relative;
            width: 150px;
            height: 150px;
            margin: 0 auto;
        }
        
        .dial {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(
                from 0deg,
                var(--blood) 0deg,
                var(--venom) 180deg,
                var(--blood) 360deg
            );
            position: relative;
            cursor: grab;
            box-shadow: 
                inset 0 0 30px rgba(0,0,0,0.8),
                0 0 40px rgba(139,0,0,0.5);
        }
        
        .dial-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            background: var(--ash);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            font-weight: 700;
            color: var(--venom);
            text-shadow: 0 0 10px currentColor;
        }
        
        .dial-label {
            text-align: center;
            margin-top: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            opacity: 0.8;
        }
        
        /* Choice Buttons */
        .choices-container {
            flex: 1;
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            justify-content: center;
        }
        
        .choice-btn {
            padding: 20px;
            background: transparent;
            border: 1px solid var(--blood);
            color: var(--bone);
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .choice-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--blood);
            transition: left 0.3s ease;
            z-index: -1;
        }
        
        .choice-btn:hover::before {
            left: 0;
        }
        
        .choice-btn:hover {
            color: var(--bone);
            transform: translateX(5px);
        }
        
        .choice-btn.danger {
            border-color: var(--venom);
        }
        
        .choice-btn.danger::before {
            background: var(--venom);
        }
        
        /* Progress Ring */
        .progress-ring {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
        }
        
        .progress-ring svg {
            transform: rotate(-90deg);
        }
        
        .progress-ring-bg {
            fill: none;
            stroke: rgba(139,0,0,0.2);
            stroke-width: 4;
        }
        
        .progress-ring-fill {
            fill: none;
            stroke: var(--venom);
            stroke-width: 4;
            stroke-linecap: round;
            transition: stroke-dasharray 0.5s ease;
        }
        
        /* Vibration Sync Bar */
        .vibration-bar {
            position: absolute;
            bottom: 30px;
            left: 30px;
            right: 330px;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .vibration-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--venom) 0%, var(--blood) 100%);
            width: 0%;
            transition: width 0.2s ease;
        }
        
        /* Fetish Score Display */
        .fetish-scores {
            position: absolute;
            top: 100px;
            left: 30px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            display: none;
        }
        
        .fetish-scores.active {
            display: block;
        }
        
        .score-item {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            opacity: 0.8;
        }
        
        .score-bar {
            width: 100px;
            height: 4px;
            background: rgba(255,255,255,0.1);
            margin-left: 20px;
            position: relative;
            top: 8px;
        }
        
        .score-fill {
            height: 100%;
            background: var(--venom);
            transition: width 0.5s ease;
        }
        
        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--void);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20000;
            transition: opacity 0.5s ease;
        }
        
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .dna-spiral {
            width: 200px;
            height: 200px;
            position: relative;
            animation: spiral-rotate 3s linear infinite;
        }
        
        @keyframes spiral-rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .spiral-strand {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid var(--venom);
            border-radius: 50% 0;
            opacity: 0.5;
        }
        
        .spiral-strand:nth-child(2) {
            transform: rotate(60deg);
            border-color: var(--blood);
        }
        
        .spiral-strand:nth-child(3) {
            transform: rotate(120deg);
            border-color: var(--crimson);
        }
        
        .loading-text {
            margin-top: 40px;
            font-size: 1.2em;
            opacity: 0.8;
            text-align: center;
        }
        
        .loading-subtext {
            font-size: 0.9em;
            opacity: 0.5;
            margin-top: 10px;
        }
        
        /* Mobile Responsive */
        @media (max-width: 768px) {
            .control-panel {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                width: 100%;
                height: 200px;
                border-left: none;
                border-top: 1px solid var(--blood);
                flex-direction: row;
            }
            
            .intensity-dial {
                border-bottom: none;
                border-right: 1px solid rgba(139,0,0,0.3);
            }
            
            .dial-container {
                width: 100px;
                height: 100px;
            }
            
            .scene-viewer {
                margin-bottom: 200px;
            }
        }
        
        /* Special Effects */
        .glitch {
            animation: glitch 0.3s ease;
        }
        
        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
        }
        
        .shake {
            animation: shake 0.5s ease;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
        
        /* Scanlines Effect */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 15000;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255,255,255,0.03) 2px,
                rgba(255,255,255,0.03) 4px
            );
            animation: scanlines 8s linear infinite;
        }
        
        @keyframes scanlines {
            0% { transform: translateY(0); }
            100% { transform: translateY(10px); }
        }
    </style>
</head>
<body>
    <!-- Custom Cursor -->
    <div class="cursor" id="cursor"></div>
    
    <!-- Scanlines Overlay -->
    <div class="scanlines"></div>
    
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="dna-spiral">
            <div class="spiral-strand"></div>
            <div class="spiral-strand"></div>
            <div class="spiral-strand"></div>
        </div>
        <div class="loading-text">Initializing Neural Pathways...</div>
        <div class="loading-subtext">Preparing your personalized experience</div>
    </div>
    
    <!-- Main Experience Container -->
    <div class="experience-container">
        <!-- Scene Viewer -->
        <div class="scene-viewer" id="sceneViewer">
            <!-- Background Layer -->
            <div class="scene-layer bg-layer">
                <img id="bgImage" src="" alt="Background" style="width: 100%; height: 100%; object-fit: cover;">
            </div>
            
            <!-- Subject Layer -->
            <div class="scene-layer subject-layer">
                <img id="subjectImage" src="" alt="Subject" class="subject-image">
            </div>
            
            <!-- Effects Layer -->
            <div class="scene-layer effects-layer"></div>
            
            <!-- Text Layer -->
            <div class="text-layer" id="textLayer">
                <div class="scene-text" id="sceneText"></div>
            </div>
            
            <!-- Progress Ring -->
            <div class="progress-ring">
                <svg width="60" height="60">
                    <circle cx="30" cy="30" r="26" class="progress-ring-bg"></circle>
                    <circle cx="30" cy="30" r="26" class="progress-ring-fill" 
                            stroke-dasharray="163.36" 
                            stroke-dashoffset="163.36"
                            id="progressFill"></circle>
                </svg>
            </div>
            
            <!-- Vibration Sync Bar -->
            <div class="vibration-bar">
                <div class="vibration-fill" id="vibrationFill"></div>
            </div>
            
            <!-- Fetish Scores -->
            <div class="fetish-scores" id="fetishScores">
                <h3 style="margin-bottom: 15px; color: var(--venom);">Fetish Resonance</h3>
                <div class="score-item">
                    <span>Dominance</span>
                    <div class="score-bar">
                        <div class="score-fill" id="dominanceScore" style="width: 0%"></div>
                    </div>
                </div>
                <div class="score-item">
                    <span>Bondage</span>
                    <div class="score-bar">
                        <div class="score-fill" id="bondageScore" style="width: 0%"></div>
                    </div>
                </div>
                <div class="score-item">
                    <span>Humiliation</span>
                    <div class="score-bar">
                        <div class="score-fill" id="humiliationScore" style="width: 0%"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Control Panel -->
        <div class="control-panel">
            <!-- Intensity Dial -->
            <div class="intensity-dial">
                <div class="dial-container">
                    <div class="dial" id="intensityDial">
                        <div class="dial-center" id="dialValue">3</div>
                    </div>
                </div>
                <div class="dial-label">Intensity</div>
            </div>
            
            <!-- Choice Buttons -->
            <div class="choices-container" id="choicesContainer">
                <!-- Dynamic choices will be inserted here -->
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // FORBIDDEN STORIES V3 - ULTIMATE ENGINE
        // ==========================================
        
        class ForbiddenEngine {
            constructor() {
                this.state = {
                    intensity: 3,
                    currentScene: 0,
                    totalScenes: 0,
                    choices: [],
                    fetishScores: {
                        dominance: 0,
                        bondage: 0,
                        humiliation: 0,
                        worship: 0,
                        pain: 0,
                        control: 0
                    },
                    sessionSeed: this.generateSeed(),
                    imageCache: new Map(),
                    textCache: new Map(),
                    audioContext: null,
                    hapticPatterns: {
                        soft: [50, 100, 50],
                        medium: [100, 50, 100, 50, 100],
                        hard: [200, 100, 200, 100, 200],
                        climax: [300, 100, 300, 100, 500, 200, 1000]
                    }
                };
                
                this.imageSources = {
                    stableDiffusion: new StableDiffusionAPI(),
                    waifuPics: new WaifuPicsAPI(),
                    unsplash: new UnsplashAPI(),
                    composite: new ImageCompositor()
                };
                
                this.textGenerators = {
                    markov: new MarkovChainGenerator(),
                    gpt: new GPTAdapter(),
                    mistral: new MistralAdapter()
                };
                
                this.init();
            }
            
            generateSeed() {
                const timestamp = Date.now();
                const random = Math.random() * 1000000;
                const userAgent = navigator.userAgent;
                const seedString = `${timestamp}-${random}-${userAgent}`;
                return this.hashCode(seedString);
            }
            
            hashCode(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash);
            }
            
            async init() {
                // Initialize audio context
                this.initAudio();
                
                // Initialize cursor
                this.initCursor();
                
                // Initialize intensity dial
                this.initIntensityDial();
                
                // Load initial scene
                setTimeout(() => {
                    document.getElementById('loadingOverlay').classList.add('hidden');
                    this.generateScene();
                }, 3000);
            }
            
            initAudio() {
                if (window.AudioContext) {
                    this.state.audioContext = new AudioContext();
                    this.createAtmosphere();
                }
            }
            
            createAtmosphere() {
                const ctx = this.state.audioContext;
                
                // Create dark ambient drone
                const osc1 = ctx.createOscillator();
                const osc2 = ctx.createOscillator();
                const gain1 = ctx.createGain();
                const gain2 = ctx.createGain();
                const filter = ctx.createBiquadFilter();
                
                osc1.type = 'sine';
                osc2.type = 'triangle';
                osc1.frequency.value = 55; // Low A
                osc2.frequency.value = 82.5; // Low E
                
                gain1.gain.value = 0.05;
                gain2.gain.value = 0.03;
                
                filter.type = 'lowpass';
                filter.frequency.value = 200;
                filter.Q.value = 10;
                
                osc1.connect(gain1);
                osc2.connect(gain2);
                gain1.connect(filter);
                gain2.connect(filter);
                filter.connect(ctx.destination);
                
                osc1.start();
                osc2.start();
                
                // Store for later manipulation
                this.atmosphere = { osc1, osc2, gain1, gain2, filter };
            }
            
            initCursor() {
                const cursor = document.getElementById('cursor');
                document.addEventListener('mousemove', (e) => {
                    cursor.style.left = e.clientX + 'px';
                    cursor.style.top = e.clientY + 'px';
                });
                
                document.addEventListener('mousedown', () => {
                    cursor.classList.add('active');
                });
                
                document.addEventListener('mouseup', () => {
                    cursor.classList.remove('active');
                });
            }
            
            initIntensityDial() {
                const dial = document.getElementById('intensityDial');
                const dialValue = document.getElementById('dialValue');
                let isDragging = false;
                let startAngle = 0;
                let currentAngle = 0;
                
                const updateDial = (angle) => {
                    const intensity = Math.round((angle / 360) * 5) + 1;
                    this.state.intensity = Math.max(1, Math.min(5, intensity));
                    dialValue.textContent = this.state.intensity;
                    dial.style.transform = `rotate(${angle}deg)`;
                    
                    // Update atmosphere based on intensity
                    if (this.atmosphere) {
                        this.atmosphere.filter.frequency.value = 200 + (this.state.intensity * 100);
                        this.atmosphere.gain1.gain.value = 0.05 + (this.state.intensity * 0.02);
                    }
                };
                
                dial.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    const rect = dial.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    startAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const rect = dial.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX) * 180 / Math.PI;
                    currentAngle = angle - startAngle;
                    
                    updateDial(currentAngle);
                });
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
            }
            
            async generateScene() {
                const sceneData = await this.createSceneData();
                await this.renderScene(sceneData);
            }
            
            async createSceneData() {
                // Generate unique content based on seed and current state
                const seed = this.state.sessionSeed + this.state.currentScene;
                const intensity = this.state.intensity;
                
                // Select random image sources
                const imageSources = this.shuffleArray(['stableDiffusion', 'waifuPics', 'unsplash']);
                const primarySource = imageSources[0];
                const secondarySource = imageSources[1];
                
                // Generate prompts based on intensity and fetish scores
                const prompts = this.generatePrompts(intensity);
                
                // Fetch images from multiple sources
                const [mainImage, bgImage] = await Promise.all([
                    this.fetchImage(primarySource, prompts.main),
                    this.fetchImage(secondarySource, prompts.background)
                ]);
                
                // Composite images if needed
                const finalImage = await this.imageSources.composite.blend(mainImage, bgImage, intensity);
                
                // Generate text using multi-layer approach
                const text = await this.generateText(prompts.textPrompt, intensity);
                
                // Generate choices based on current state
                const choices = this.generateChoices(intensity);
                
                return {
                    mainImage: finalImage,
                    bgImage: bgImage,
                    text: text,
                    choices: choices,
                    hapticPattern: this.selectHapticPattern(intensity),
                    audioModulation: this.calculateAudioModulation(intensity)
                };
            }
            
            generatePrompts(intensity) {
                const intensityMap = {
                    1: { main: 'elegant dominatrix portrait', bg: 'luxury hotel room', text: 'gentle' },
                    2: { main: 'leather mistress', bg: 'dark dungeon', text: 'firm' },
                    3: { main: 'latex goddess', bg: 'red room', text: 'commanding' },
                    4: { main: 'cruel mistress whip', bg: 'torture chamber', text: 'harsh' },
                    5: { main: 'extreme femdom scene', bg: 'industrial basement', text: 'merciless' }
                };
                
                const base = intensityMap[intensity];
                
                // Add variety based on fetish scores
                const fetishModifiers = [];
                if (this.state.fetishScores.bondage > 50) fetishModifiers.push('rope', 'chains');
                if (this.state.fetishScores.worship > 50) fetishModifiers.push('boots', 'heels');
                if (this.state.fetishScores.humiliation > 50) fetishModifiers.push('collar', 'leash');
                
                return {
                    main: `${base.main} ${fetishModifiers.join(' ')}`,
                    background: base.bg,
                    textPrompt: base.text
                };
            }
            
            async fetchImage(source, prompt) {
                // Check cache first
                const cacheKey = `${source}-${prompt}`;
                if (this.state.imageCache.has(cacheKey)) {
                    return this.state.imageCache.get(cacheKey);
                }
                
                let image;
                try {
                    image = await this.imageSources[source].generate(prompt);
                } catch (error) {
                    console.error(`Failed to fetch from ${source}:`, error);
                    // Fallback image
                    image = this.getFallbackImage(prompt);
                }
                
                this.state.imageCache.set(cacheKey, image);
                return image;
            }
            
            async generateText(style, intensity) {
                // Multi-layer text generation
                const baseText = await this.textGenerators.markov.generate(style);
                const refinedText = await this.textGenerators.gpt.refine(baseText, intensity);
                const finalText = await this.textGenerators.mistral.intensify(refinedText, intensity);
                
                // Apply style variations
                return this.applyTextStyles(finalText, intensity);
            }
            
            applyTextStyles(text, intensity) {
                const styles = {
                    1: (t) => `<span class="whisper-text">${t}</span>`,
                    2: (t) => t,
                    3: (t) => t.replace(/命令/g, '<span class="command-text">命令</span>'),
                    4: (t) => `<span class="command-text">${t}</span>`,
                    5: (t) => `<span class="command-text glitch">${t}</span>`
                };
                
                return styles[intensity](text);
            }
            
            generateChoices(intensity) {
                const choiceSets = {
                    1: [
                        { text: '従う', value: 'submit', danger: false },
                        { text: '躊躇する', value: 'hesitate', danger: false },
                        { text: '逃げる', value: 'escape', danger: true }
                    ],
                    2: [
                        { text: '跪く', value: 'kneel', danger: false },
                        { text: '抵抗する', value: 'resist', danger: false },
                        { text: '拒否する', value: 'refuse', danger: true }
                    ],
                    3: [
                        { text: '服従する', value: 'obey', danger: false },
                        { text: '懇願する', value: 'beg', danger: false },
                        { text: '反抗する', value: 'rebel', danger: true }
                    ],
                    4: [
                        { text: '崇拝する', value: 'worship', danger: false },
                        { text: '耐える', value: 'endure', danger: false },
                        { text: '壊れる', value: 'break', danger: true }
                    ],
                    5: [
                        { text: '完全服従', value: 'total_submission', danger: false },
                        { text: '限界', value: 'limit', danger: true },
                        { text: '崩壊', value: 'collapse', danger: true }
                    ]
                };
                
                return this.shuffleArray(choiceSets[intensity]);
            }
            
            selectHapticPattern(intensity) {
                const patterns = ['soft', 'medium', 'hard', 'hard', 'climax'];
                return patterns[intensity - 1];
            }
            
            calculateAudioModulation(intensity) {
                return {
                    frequency: 200 + (intensity * 100),
                    volume: 0.05 + (intensity * 0.03),
                    distortion: intensity > 3 ? 0.1 * (intensity - 3) : 0
                };
            }
            
            async renderScene(sceneData) {
                // Update images
                document.getElementById('bgImage').src = sceneData.bgImage;
                document.getElementById('subjectImage').src = sceneData.mainImage;
                
                // Animate text entry
                const textLayer = document.getElementById('textLayer');
                const sceneText = document.getElementById('sceneText');
                
                textLayer.classList.remove('active');
                setTimeout(() => {
                    sceneText.innerHTML = sceneData.text;
                    textLayer.classList.add('active');
                }, 300);
                
                // Update choices
                this.renderChoices(sceneData.choices);
                
                // Trigger haptic feedback
                this.triggerHaptic(sceneData.hapticPattern);
                
                // Update audio
                this.updateAudio(sceneData.audioModulation);
                
                // Update progress
                this.updateProgress();
                
                // Show fetish scores after 3rd scene
                if (this.state.currentScene >= 3) {
                    document.getElementById('fetishScores').classList.add('active');
                    this.updateFetishScores();
                }
            }
            
            renderChoices(choices) {
                const container = document.getElementById('choicesContainer');
                container.innerHTML = '';
                
                choices.forEach((choice, index) => {
                    const btn = document.createElement('button');
                    btn.className = `choice-btn ${choice.danger ? 'danger' : ''}`;
                    btn.textContent = choice.text;
                    btn.onclick = () => this.makeChoice(choice.value, index);
                    
                    // Stagger animation
                    btn.style.opacity = '0';
                    btn.style.transform = 'translateX(-20px)';
                    container.appendChild(btn);
                    
                    setTimeout(() => {
                        btn.style.transition = 'all 0.5s ease';
                        btn.style.opacity = '1';
                        btn.style.transform = 'translateX(0)';
                    }, 100 * index);
                });
            }
            
            triggerHaptic(pattern) {
                if ('vibrate' in navigator) {
                    navigator.vibrate(this.state.hapticPatterns[pattern]);
                }
                
                // Visual feedback
                const vibrationFill = document.getElementById('vibrationFill');
                vibrationFill.style.width = '100%';
                setTimeout(() => {
                    vibrationFill.style.width = '0%';
                }, this.state.hapticPatterns[pattern].reduce((a, b) => a + b, 0));
            }
            
            updateAudio(modulation) {
                if (!this.atmosphere) return;
                
                // Smooth transitions
                const currentFreq = this.atmosphere.filter.frequency.value;
                const targetFreq = modulation.frequency;
                const steps = 30;
                const stepSize = (targetFreq - currentFreq) / steps;
                
                let step = 0;
                const interval = setInterval(() => {
                    if (step >= steps) {
                        clearInterval(interval);
                        return;
                    }
                    
                    this.atmosphere.filter.frequency.value += stepSize;
                    this.atmosphere.gain1.gain.value = modulation.volume;
                    step++;
                }, 50);
            }
            
            updateProgress() {
                const progress = (this.state.currentScene / this.state.totalScenes) * 100;
                const circumference = 2 * Math.PI * 26;
                const offset = circumference - (progress / 100 * circumference);
                
                document.getElementById('progressFill').style.strokeDashoffset = offset;
            }
            
            updateFetishScores() {
                const scores = this.state.fetishScores;
                
                Object.entries(scores).forEach(([fetish, score]) => {
                    const element = document.getElementById(`${fetish}Score`);
                    if (element) {
                        element.style.width = `${Math.min(score, 100)}%`;
                    }
                });
            }
            
            async makeChoice(value, index) {
                // Record choice
                this.state.choices.push({ scene: this.state.currentScene, value, index });
                
                // Update fetish scores based on choice
                this.updateFetishScoresFromChoice(value);
                
                // Apply screen effect based on choice
                if (value.includes('resist') || value.includes('rebel')) {
                    document.getElementById('sceneViewer').classList.add('shake');
                    setTimeout(() => {
                        document.getElementById('sceneViewer').classList.remove('shake');
                    }, 500);
                } else if (value.includes('submit') || value.includes('worship')) {
                    document.getElementById('sceneViewer').classList.add('glitch');
                    setTimeout(() => {
                        document.getElementById('sceneViewer').classList.remove('glitch');
                    }, 300);
                }
                
                // Progress to next scene
                this.state.currentScene++;
                
                if (this.state.currentScene < this.state.totalScenes) {
                    await this.generateScene();
                } else {
                    this.endSession();
                }
            }
            
            updateFetishScoresFromChoice(value) {
                const scoreMap = {
                    'submit': { dominance: 10, control: 5 },
                    'kneel': { dominance: 15, worship: 10 },
                    'obey': { dominance: 20, control: 10 },
                    'worship': { worship: 25, dominance: 15 },
                    'resist': { dominance: -5, pain: 10 },
                    'rebel': { dominance: -10, pain: 15 },
                    'beg': { humiliation: 20, dominance: 10 },
                    'endure': { pain: 20, control: 15 },
                    'break': { humiliation: 30, pain: 25 },
                    'total_submission': { dominance: 30, control: 25, worship: 20 }
                };
                
                const scores = scoreMap[value] || {};
                Object.entries(scores).forEach(([fetish, points]) => {
                    this.state.fetishScores[fetish] = Math.max(0, 
                        Math.min(100, this.state.fetishScores[fetish] + points)
                    );
                });
            }
            
            endSession() {
                // Show completion screen
                const topFetishes = this.getTopFetishes();
                this.showCompletionScreen(topFetishes);
                
                // Save session data for next time
                this.saveSessionData();
            }
            
            getTopFetishes() {
                return Object.entries(this.state.fetishScores)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 3)
                    .map(([fetish, score]) => ({ fetish, score }));
            }
            
            showCompletionScreen(topFetishes) {
                const viewer = document.getElementById('sceneViewer');
                viewer.innerHTML = `
                    <div class="completion-screen" style="
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        text-align: center;
                        padding: 40px;
                        background: rgba(0,0,0,0.9);
                        border: 1px solid var(--blood);
                        border-radius: 10px;
                    ">
                        <h2 style="font-size: 2.5em; margin-bottom: 30px; color: var(--venom);">
                            Session Complete
                        </h2>
                        <h3 style="margin-bottom: 20px;">Your Dominant Fetishes:</h3>
                        ${topFetishes.map(f => `
                            <div style="margin: 10px 0;">
                                <span style="text-transform: capitalize;">${f.fetish}</span>: 
                                <span style="color: var(--venom);">${f.score}%</span>
                            </div>
                        `).join('')}
                        <button onclick="engine.startNewSession()" style="
                            margin-top: 30px;
                            padding: 15px 40px;
                            background: var(--blood);
                            border: none;
                            color: white;
                            font-size: 1.2em;
                            cursor: pointer;
                            text-transform: uppercase;
                            letter-spacing: 2px;
                        ">
                            Next Round
                        </button>
                    </div>
                `;
            }
            
            saveSessionData() {
                const sessionData = {
                    fetishScores: this.state.fetishScores,
                    choices: this.state.choices,
                    intensity: this.state.intensity,
                    timestamp: Date.now()
                };
                
                localStorage.setItem('forbiddenSession', JSON.stringify(sessionData));
            }
            
            startNewSession() {
                // Reset state but keep learned preferences
                this.state.currentScene = 0;
                this.state.choices = [];
                this.state.sessionSeed = this.generateSeed();
                
                // Reload
                location.reload();
            }
            
            shuffleArray(array) {
                const arr = [...array];
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            }
            
            getFallbackImage(prompt) {
                // Fallback images based on prompt keywords
                const fallbacks = {
                    'dominatrix': 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjYwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwMCIgaGVpZ2h0PSI2MDAiIGZpbGw9IiMxYTFhMWEiLz4KPHRleHQgeD0iNDAwIiB5PSIzMDAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSI0MCIgZmlsbD0iIzhCMDAwMCIgdGV4dC1hbmNob3I9Im1pZGRsZSI+RG9taW5hdHJpeDwvdGV4dD4KPC9zdmc+',
                    'dungeon': 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjYwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjgwMCIgaGVpZ2h0PSI2MDAiIGZpbGw9IiMwYTBhMGEiLz4KPHRleHQgeD0iNDAwIiB5PSIzMDAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSI0MCIgZmlsbD0iIzRhMDAwMCIgdGV4dC1hbmNob3I9Im1pZGRsZSI+RHVuZ2VvbjwvdGV4dD4KPC9zdmc+'
                };
                
                const key = Object.keys(fallbacks).find(k => prompt.includes(k));
                return fallbacks[key] || fallbacks['dominatrix'];
            }
        }
        
        // ==========================================
        // API ADAPTERS
        // ==========================================
        
        class StableDiffusionAPI {
            async generate(prompt) {
                // Simulate API call
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // In production: actual API call to SD
                const mockImages = [
                    'https://images.unsplash.com/photo-1581833971358-2c8b550f87b3?w=800&q=90',
                    'https://images.unsplash.com/photo-1516589178581-6cd7833ae3b2?w=800&q=90'
                ];
                
                return mockImages[Math.floor(Math.random() * mockImages.length)];
            }
        }
        
        class WaifuPicsAPI {
            async generate(prompt) {
                try {
                    // Use SFW endpoint for demo
                    const response = await fetch('https://api.waifu.pics/sfw/waifu');
                    const data = await response.json();
                    return data.url;
                } catch (error) {
                    console.error('WaifuPics API error:', error);
                    return null;
                }
            }
        }
        
        class UnsplashAPI {
            async generate(prompt) {
                // Simulate API call
                const keywords = prompt.split(' ').slice(0, 2).join(',');
                return `https://source.unsplash.com/800x600/?${keywords},dark`;
            }
        }
        
        class ImageCompositor {
            async blend(mainImage, bgImage, intensity) {
                // In production: use Canvas API or WebGL for real compositing
                // For now, return main image
                return mainImage;
            }
        }
        
        // ==========================================
        // TEXT GENERATORS
        // ==========================================
        
        class MarkovChainGenerator {
            constructor() {
                this.chains = {
                    gentle: [
                        "あなたの瞳に映る私を見て",
                        "膝をついて、ゆっくりと",
                        "今夜は特別な時間"
                    ],
                    firm: [
                        "言われた通りにしなさい",
                        "躊躇は許されない",
                        "私の命令に従いなさい"
                    ],
                    commanding: [
                        "跪け。今すぐに。",
                        "お前の意思など関係ない",
                        "完全なる服従を示せ"
                    ],
                    harsh: [
                        "惨めに這いつくばれ",
                        "その醜い姿を晒せ",
                        "苦痛の中で私を崇めろ"
                    ],
                    merciless: [
                        "壊れるまで従え",
                        "限界など存在しない",
                        "完全なる支配下に堕ちろ"
                    ]
                };
            }
            
            async generate(style) {
                const chain = this.chains[style] || this.chains.gentle;
                const selected = chain[Math.floor(Math.random() * chain.length)];
                
                // Add variations
                const variations = [
                    selected,
                    selected + "。震える手で、あなたは応える。",
                    "「" + selected + "」彼女の声が響く。"
                ];
                
                return variations[Math.floor(Math.random() * variations.length)];
            }
        }
        
        class GPTAdapter {
            async refine(text, intensity) {
                // Simulate GPT refinement
                const intensityModifiers = {
                    1: "優しく",
                    2: "厳しく",
                    3: "冷たく",
                    4: "残酷に",
                    5: "容赦なく"
                };
                
                const modifier = intensityModifiers[intensity];
                return `${text} 彼女は${modifier}微笑む。あなたの身体が、本能的に反応する。`;
            }
        }
        
        class MistralAdapter {
            async intensify(text, intensity) {
                // Simulate Mistral intensification
                if (intensity >= 4) {
                    text += " 逃げ場はない。完全なる支配の下で、あなたは新しい自分を発見する。";
                }
                
                return text;
            }
        }
        
        // ==========================================
        // INITIALIZE ENGINE
        // ==========================================
        
        const engine = new ForbiddenEngine();
        
        // Set initial scene count
        engine.state.totalScenes = 5 + Math.floor(Math.random() * 4); // 5-8 scenes
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            const choices = document.querySelectorAll('.choice-btn');
            if (e.key === '1' && choices[0]) choices[0].click();
            if (e.key === '2' && choices[1]) choices[1].click();
            if (e.key === '3' && choices[2]) choices[2].click();
            
            // Intensity shortcuts
            if (e.key === '+' || e.key === '=') {
                engine.state.intensity = Math.min(5, engine.state.intensity + 1);
                document.getElementById('dialValue').textContent = engine.state.intensity;
            }
            if (e.key === '-' || e.key === '_') {
                engine.state.intensity = Math.max(1, engine.state.intensity - 1);
                document.getElementById('dialValue').textContent = engine.state.intensity;
            }
        });
        
        // Performance optimization
        if ('requestIdleCallback' in window) {
            requestIdleCallback(() => {
                // Preload common images
                const preloadImages = [
                    'https://source.unsplash.com/800x600/?dark,room',
                    'https://source.unsplash.com/800x600/?leather,black'
                ];
                
                preloadImages.forEach(src => {
                    const img = new Image();
                    img.src = src;
                });
            });
        }
        
        console.log('Forbidden Stories v3 - Ultimate Engine Initialized');
        console.log('Warning: This system pushes boundaries. Prepare for intensity.');
    </script>
</body>
</html>
